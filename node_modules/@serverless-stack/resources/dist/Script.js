import path from "path";
import url from "url";
import { Construct } from "constructs";
import * as cdk from "aws-cdk-lib";
import * as lambda from "aws-cdk-lib/aws-lambda";
import { Function as Fn, } from "./Function.js";
const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
/////////////////////
// Construct
/////////////////////
/**
 * The `Script` construct is a higher level CDK construct that makes it easy to run a script in a Lambda function during the deployment process.
 *
 * @example
 *
 * ```js
 * import { Script } from "@serverless-stack/resources";
 *
 * new Script(stack, "Script", {
 *   onCreate: "src/function.create",
 *   onUpdate: "src/function.update",
 *   onDelete: "src/function.delete",
 * });
 * ```
 */
export class Script extends Construct {
    constructor(scope, id, props) {
        super(scope, id);
        if (props.function)
            this.checkDeprecatedFunction();
        // Validate deprecated "function" prop
        // Validate at least 1 function is provided
        if (!props.onCreate && !props.onUpdate && !props.onDelete) {
            throw new Error(`Need to provide at least one of "onCreate", "onUpdate", or "onDelete" functions for the "${this.node.id}" Script`);
        }
        const root = scope.node.root;
        this.props = props;
        this.createFunction = this.createUserFunction("onCreate", props.onCreate);
        this.updateFunction = this.createUserFunction("onUpdate", props.onUpdate);
        this.deleteFunction = this.createUserFunction("onDelete", props.onDelete);
        const crFunction = this.createCustomResourceFunction();
        this.createCustomResource(root, crFunction);
    }
    /**
     * Grants additional permissions to the script
     *
     * @example
     * ```js
     * script.attachPermissions(["s3"]);
     * ```
     */
    attachPermissions(permissions) {
        this.createFunction?.attachPermissions(permissions);
        this.updateFunction?.attachPermissions(permissions);
        this.deleteFunction?.attachPermissions(permissions);
    }
    createUserFunction(type, fnDef) {
        if (!fnDef) {
            return;
        }
        // function is construct => return function directly
        if (fnDef instanceof Fn) {
            // validate live dev is not enabled
            if (fnDef._isLiveDevEnabled) {
                throw new Error(`Live Lambda Dev cannot be enabled for functions in the Script construct. Set the "enableLiveDev" prop for the function to "false".`);
            }
            return Fn.fromDefinition(this, `${type}Function`, fnDef, this.props.defaults?.function, `The "defaults.function" cannot be applied if an instance of a Function construct is passed in. Make sure to define the "${type}" function using FunctionProps, so the Script construct can apply the "defaults.function" to them.`);
        }
        // function is string => create function
        else if (typeof fnDef === "string") {
            return Fn.fromDefinition(this, `${type}Function`, {
                handler: fnDef,
                enableLiveDev: false,
            }, {
                timeout: 900,
                ...this.props.defaults?.function,
            });
        }
        // function is props => create function
        return Fn.fromDefinition(this, `${type}Function`, {
            ...fnDef,
            enableLiveDev: false,
        }, {
            timeout: 900,
            ...this.props.defaults?.function,
        });
    }
    createCustomResourceFunction() {
        const handler = new lambda.Function(this, "ScriptHandler", {
            code: lambda.Code.fromAsset(path.join(__dirname, "Script")),
            runtime: lambda.Runtime.NODEJS_16_X,
            handler: "index.handler",
            timeout: cdk.Duration.minutes(15),
            memorySize: 1024,
        });
        this.createFunction?.grantInvoke(handler);
        this.updateFunction?.grantInvoke(handler);
        this.deleteFunction?.grantInvoke(handler);
        return handler;
    }
    createCustomResource(app, crFunction) {
        // Note: "BuiltAt" is set to current timestamp to ensure the Custom
        //       Resource function is run on every update.
        //
        //       Do not use the current timestamp in Live mode, b/c we want the
        //       this custom resource to remain the same in CloudFormation template
        //       when rebuilding infrastructure. Otherwise, there will always be
        //       a change when rebuilding infrastructure b/c the "BuildAt" property
        //       changes on each build.
        const builtAt = app.local ? app.debugStartedAt : Date.now();
        new cdk.CustomResource(this, "ScriptResource", {
            serviceToken: crFunction.functionArn,
            resourceType: "Custom::SSTScript",
            properties: {
                UserCreateFunction: this.createFunction?.functionName,
                UserUpdateFunction: this.updateFunction?.functionName,
                UserDeleteFunction: this.deleteFunction?.functionName,
                UserParams: JSON.stringify(this.props.params || {}),
                BuiltAt: builtAt,
            },
        });
    }
    checkDeprecatedFunction() {
        throw new Error(`The "function" property has been replaced by "onCreate" and "onUpdate". More details on upgrading - https://docs.sst.dev/constructs/Script#upgrading-to-v0460`);
    }
}
